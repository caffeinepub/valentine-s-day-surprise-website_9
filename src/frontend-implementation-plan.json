{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Remote Save/Restore via Shareable Link with Local Fallback",
  "requirements": [
    {
      "id": "REQ-11",
      "summary": "Add link-based, cross-device restoration by fetching a server snapshot when a saveId is present in the URL, while keeping local persistence as fallback.",
      "acceptanceCriteria": [
        "Saving progress creates or updates a server-stored snapshot containing: Page 1 message, Page 2 three video titles, Page 2 selected videos, and Page 3 final message.",
        "Given a shareable link generated by the app, opening the link in a different browser/device restores the exact saved snapshot (including videos) without relying on prior local browser storage.",
        "Server persistence works in major modern browsers (Chrome, Safari, Firefox, Edge) via the existing React frontend + Motoko backend canister."
      ],
      "file_operations": [
        {
          "path": "frontend/src/App.tsx",
          "operation": "modify",
          "description": "On app mount, parse saveId from the URL; if present, attempt remote restore first (show loading UI until resolved) and hydrate landingMessage/videoSlots/finalMessage from the returned snapshot, including setting video preview URLs suitable for playback. If remote restore fails, show a non-blocking English error and then fall back to existing local loadProgress()."
        },
        {
          "path": "frontend/src/lib/valentineRemoteProgress.ts",
          "operation": "create",
          "description": "Create a small client for remote create/update/fetch of Valentine snapshots using the existing backend actor. Keep the API intent-focused (create, update, fetch) and return typed results for the React UI. If videos are stored as blob-storage references, use the blob-storage ExternalBlob direct URL capability to produce playable URLs. Verify the component's usage instructions before implementing."
        },
        {
          "path": "frontend/src/lib/saveId.ts",
          "operation": "create",
          "description": "Add URL helpers to read/write saveId using URLSearchParams and the History API (replaceState/pushState) without full reload, plus helpers to build a shareable link string."
        },
        {
          "path": "frontend/src/backend.d.ts",
          "operation": "modify",
          "description": "Extend the frontend backendInterface TypeScript definitions to include the remote snapshot methods needed for create/update/fetch, including savedAt and error variants/messages so the UI can display clear English feedback."
        }
      ]
    },
    {
      "id": "REQ-13",
      "summary": "Rebuild the Save button flow to create a new remote save when no saveId exists, update the URL without reload, and update the existing remote save on subsequent clicks while keeping clear status text.",
      "acceptanceCriteria": [
        "If the current URL does not contain a saveId, clicking Save triggers creation of a new remote save and updates the browser URL (using history API) to include the saveId without a full page reload.",
        "If the URL contains a saveId, clicking Save updates that same remote save (does not create a second save).",
        "The Save button continues to display clear English status text for saving/success/error (e.g., \"Saving...\", \"Saved\", \"Save Failed\", and \"Last saved at HH:MM\").",
        "Any new user-facing text introduced for link sharing and remote saving is in English."
      ],
      "file_operations": [
        {
          "path": "frontend/src/App.tsx",
          "operation": "modify",
          "description": "Update handleSave to prioritize remote saving: if no saveId in URL, call remote create to obtain {saveId, writeToken}, store writeToken locally (scoped to saveId), and update the URL via history API; if saveId exists, call remote update using stored writeToken. Keep the existing status state machine (saving/saved/error) and update lastSavedAt from remote savedAt when available; optionally also update local saveProgress as a fallback cache."
        },
        {
          "path": "frontend/src/components/SaveProgressButton.tsx",
          "operation": "modify",
          "description": "Extend the Save button UI to optionally show the shareable link (or a \"Copy link\" action) after the first successful remote save, while preserving the existing Saving/Saved/Save Failed/Last saved at text behavior. Any added user-facing text must be English."
        },
        {
          "path": "frontend/src/lib/valentineRemoteProgress.ts",
          "operation": "modify",
          "description": "Add support for returning a shareable saveId and persisting/retrieving a per-saveId write token locally for subsequent updates from the same browser/session (do not require login)."
        }
      ]
    },
    {
      "id": "REQ-14",
      "summary": "Implement link-based restore with automatic hydration (including playable videos), and gracefully fall back to local restore with non-blocking error messaging on remote failures.",
      "acceptanceCriteria": [
        "Opening a URL containing a saveId causes the app to restore state from the backend snapshot automatically before rendering the editable pages (or shows a loading indicator until restored).",
        "If remote restore fails (missing saveId, not found, or backend error), the app shows a non-blocking English error message and continues to load using the existing local restore behavior when possible.",
        "Restored videos are playable in the three video slots after remote restore."
      ],
      "file_operations": [
        {
          "path": "frontend/src/App.tsx",
          "operation": "modify",
          "description": "Add a remote-restore-first boot path: when saveId exists, fetch the snapshot and set state before showing pages; if fetch fails, set an English error message (non-blocking) and then run local loadProgress(). Ensure restored videos result in valid <video src> values and remain playable in the three slots."
        },
        {
          "path": "frontend/src/pages/VideosPage.tsx",
          "operation": "modify",
          "description": "Ensure the page renders correctly when videoSlots are hydrated from remote data (e.g., when URLs are direct HTTP URLs rather than object URLs) and does not revoke remote URLs; only revoke object URLs created locally."
        },
        {
          "path": "frontend/src/lib/valentineProgressStorage.ts",
          "operation": "modify",
          "description": "Adjust local load/save helpers as needed to coexist with remote restore (e.g., expose a way to update local cache from a remote snapshot without forcing IndexedDB writes when remote videos are URL-based)."
        }
      ]
    },
    {
      "id": "REQ-15",
      "summary": "Add browser-safe video save/restore limits with user-visible feedback, and ensure remote restore provides progress/feedback rather than blocking indefinitely.",
      "acceptanceCriteria": [
        "Frontend prevents attempting a remote save when selected videos exceed defined limits and shows an English message indicating the limit was exceeded.",
        "Backend validates video payload sizes and returns a structured error when limits are exceeded.",
        "Remote restore does not block the UI indefinitely; the user can see progress/feedback while loading large snapshots.",
        "The implementation avoids deprecated browser APIs for file handling and works in major browsers."
      ],
      "file_operations": [
        {
          "path": "frontend/src/lib/valentineRemoteProgress.ts",
          "operation": "modify",
          "description": "Define explicit per-video and total payload limits for remote saves and implement preflight validation using File.size before any upload/remote save attempt; surface a structured, English error result when limits are exceeded. If using blob-storage for video handling, use the blob-storage ExternalBlob capability for upload/progress and direct URL playback. Verify the component's usage instructions before implementing."
        },
        {
          "path": "frontend/src/App.tsx",
          "operation": "modify",
          "description": "Integrate remote save preflight validation: if limits are exceeded, do not start remote save and show a clear English error message via existing Save button error UI. For remote restore, add bounded loading behavior (e.g., timeout with fallback) and a visible loading indicator/message while the restore promise is pending."
        },
        {
          "path": "frontend/src/components/SaveProgressButton.tsx",
          "operation": "modify",
          "description": "Allow the Save UI to display longer-form English error messages from limit checks and remote/backend errors without breaking layout (e.g., keep text readable and constrained)."
        }
      ]
    },
    {
      "id": "REQ-16",
      "summary": "Preserve existing local persistence as a fallback while making remote persistence the priority whenever a shareable saveId exists or is created.",
      "acceptanceCriteria": [
        "Local save/restore (localStorage + IndexedDB) continues to work for users who never create/open a share link.",
        "When a saveId is present (or created), clicking Save performs the remote save flow; local persistence may still be updated but must not be the only persistence mechanism.",
        "No previously implemented page navigation or in-memory state behavior regresses (values are not lost when switching pages during a session)."
      ],
      "file_operations": [
        {
          "path": "frontend/src/App.tsx",
          "operation": "modify",
          "description": "Keep existing lifted in-memory state and navigation unchanged. Update save logic so remote save is preferred when saveId exists/gets created, while still optionally calling saveProgress() to keep the local offline cache updated. Ensure switching pages does not reset any state."
        },
        {
          "path": "frontend/src/lib/valentineProgressStorage.ts",
          "operation": "modify",
          "description": "Maintain existing localStorage/IndexedDB persistence behavior for users without a saveId, and ensure local save/restore remains functional as an offline/quick-reload fallback alongside the new remote flow."
        }
      ]
    }
  ]
}