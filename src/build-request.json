{
  "kind": "build_request",
  "title": "Rebuild Save Button with Server-Side Persistence and Shareable Link (Cross-Device)",
  "priority": "normal",
  "requirements": [
    {
      "id": "REQ-11",
      "text": "Implement server-side persistence for the Valentine progress so that a saved state can be restored from any browser/device by opening the same shareable link.",
      "target": "both",
      "source": {
        "messageIds": [
          "recent-messages-6"
        ],
        "quotes": [
          "- The save button should ensure that every single save remains persistent and can be accessed from different browsers and devices.\n- Users should be able to open the same link and view the exact content they saved."
        ]
      },
      "acceptanceCriteria": [
        "Saving progress creates or updates a server-stored snapshot containing: Page 1 message, Page 2 three video titles, Page 2 selected videos, and Page 3 final message.",
        "Given a shareable link generated by the app, opening the link in a different browser/device restores the exact saved snapshot (including videos) without relying on prior local browser storage.",
        "Server persistence works in major modern browsers (Chrome, Safari, Firefox, Edge) via the existing React frontend + Motoko backend canister."
      ]
    },
    {
      "id": "REQ-12",
      "text": "Extend the Motoko backend (single main actor) with an API for creating, updating, and fetching shareable saved snapshots using an unguessable saveId plus a write token (capability) to control updates.",
      "target": "backend",
      "source": {
        "messageIds": [
          "recent-messages-6"
        ],
        "quotes": [
          "Please ensure the solution is scalable, secure, and compatible with major web browsers.",
          "Be cautious of potential cross-browser compatibility issues and ensure that the saved content is correctly synchronized across devices."
        ]
      },
      "acceptanceCriteria": [
        "Backend exposes methods to: (1) create a new save record and return {saveId, writeToken}; (2) update an existing save record when provided {saveId, writeToken}; (3) fetch a save record by saveId for read-only restore.",
        "Backend rejects update attempts with an invalid/absent writeToken.",
        "Backend stores and returns a savedAt timestamp for the snapshot.",
        "Backend enforces size limits and returns clear error variants/messages when payloads exceed limits (to protect performance and canister memory)."
      ]
    },
    {
      "id": "REQ-13",
      "text": "Update the frontend Save button flow to support remote saves: on first remote save, generate and store a shareable link (containing saveId) and keep the app synced to that remote save on subsequent saves.",
      "target": "frontend",
      "source": {
        "messageIds": [
          "recent-messages-6"
        ],
        "quotes": [
          "Your task is to design and implement a rebuilt save button for a webpage that allows users to save content seamlessly."
        ]
      },
      "acceptanceCriteria": [
        "If the current URL does not contain a saveId, clicking Save triggers creation of a new remote save and updates the browser URL (using history API) to include the saveId without a full page reload.",
        "If the URL contains a saveId, clicking Save updates that same remote save (does not create a second save).",
        "The Save button continues to display clear English status text for saving/success/error (e.g., \"Saving...\", \"Saved\", \"Save Failed\", and \"Last saved at HH:MM\").",
        "Any new user-facing text introduced for link sharing and remote saving is in English."
      ]
    },
    {
      "id": "REQ-14",
      "text": "Implement link-based restore: when the app loads, if a saveId is present in the URL, fetch the server snapshot and hydrate in-memory state (and video previews) from it; otherwise fall back to the existing local restore behavior.",
      "target": "frontend",
      "source": {
        "messageIds": [
          "recent-messages-6"
        ],
        "quotes": [
          "Users should be able to open the same link and view the exact content they saved."
        ]
      },
      "acceptanceCriteria": [
        "Opening a URL containing a saveId causes the app to restore state from the backend snapshot automatically before rendering the editable pages (or shows a loading indicator until restored).",
        "If remote restore fails (missing saveId, not found, or backend error), the app shows a non-blocking English error message and continues to load using the existing local restore behavior when possible.",
        "Restored videos are playable in the three video slots after remote restore."
      ]
    },
    {
      "id": "REQ-15",
      "text": "Add scalable, browser-safe handling for saving and restoring videos through the backend, including explicit per-video and total payload limits, and user-visible error feedback when limits are exceeded.",
      "target": "both",
      "source": {
        "messageIds": [
          "recent-messages-6"
        ],
        "quotes": [
          "Please ensure the solution is scalable, secure, and compatible with major web browsers. Additionally, consider how this feature might affect loading times and overall performance."
        ]
      },
      "acceptanceCriteria": [
        "Frontend prevents attempting a remote save when selected videos exceed defined limits and shows an English message indicating the limit was exceeded.",
        "Backend validates video payload sizes and returns a structured error when limits are exceeded.",
        "Remote restore does not block the UI indefinitely; the user can see progress/feedback while loading large snapshots.",
        "The implementation avoids deprecated browser APIs for file handling and works in major browsers."
      ]
    },
    {
      "id": "REQ-16",
      "text": "Preserve existing local persistence as an offline/quick-reload fallback, but ensure the rebuilt Save button prioritizes server-side persistence when a shareable saveId exists or when creating a new remote save.",
      "target": "frontend",
      "source": {
        "messageIds": [
          "recent-messages-6"
        ],
        "quotes": [
          "The save button should ensure that every single save remains persistent and can be accessed from different browsers and devices."
        ]
      },
      "acceptanceCriteria": [
        "Local save/restore (localStorage + IndexedDB) continues to work for users who never create/open a share link.",
        "When a saveId is present (or created), clicking Save performs the remote save flow; local persistence may still be updated but must not be the only persistence mechanism.",
        "No previously implemented page navigation or in-memory state behavior regresses (values are not lost when switching pages during a session)."
      ]
    }
  ],
  "constraints": [
    "Backend must remain a single Motoko actor in backend/main.mo; do not introduce additional backend services.",
    "Only create backend/migration.mo if required by an actual stable-state upgrade; follow the conditional migration policy.",
    "Do not edit any frontend immutable paths: frontend/src/hooks/useInternetIdentity.ts, frontend/src/hooks/useInternetIdentity.tsx, frontend/src/hooks/useActor.ts, frontend/src/main.tsx, frontend/src/components/ui.",
    "Use English for any user-facing text."
  ],
  "nonGoals": [
    "Adding third-party authentication providers (only Internet Identity is supported).",
    "Using external databases or third-party storage providers for persistence.",
    "Real-time sync/collaboration (e.g., live multi-user editing) beyond link-based load/save.",
    "Implementing features unrelated to the Save/share workflow (e.g., new pages or new content types)."
  ],
  "imageRequirements": {
    "required": [],
    "edits": []
  }
}